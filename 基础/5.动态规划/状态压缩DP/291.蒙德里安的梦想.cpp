// 状态压缩DP
// 可能用到位运算

// 将n*m的期盼分割成若干个1*2的矩形，求分割方案数

// 当横向的小矩形放完之后，剩下的竖着放的部分只有一种方案了
// 因此，求横向的放法即可

// 状态表示：
// f[i][j]表示第i列，j表示第i列中每行横向放置的情况。例如有5行，在第i列中2，4行含有被横向矩形的第二块覆盖的部分，那j=01010
// 状态计算
// 按列进行研究，研究第i列，需要从第i-1列转移过来，设f(i-1,k)是第i-1列的状态，f(i,j)是第i列的状态
// 注意，要先理解按位与和按位或的含义。每一位代表每一行，而整体按位与或就代表所有行(也就是一整列)
// 1. 横向的三格不能连续放置两个矩形，即 j&k==0 (如果j是1，那么k处的位置要放一个矩形的第一块；如果k是1，那么k处要放置一个矩形的第二块。因此，j和k不能同时为1，否则就会连续放置两个矩形)(这里讨论的是一位的情况，按位与是处理j和k的每一位。事实上，j和k的每一位都不能同时为1，都是0，因此最终结果上，j&k就是为0)
// 2. i-1列中所有连续空白的部分(即k中连续的0)，每个部分必须是偶数个格子，因为竖向放置的矩形占两格，要保证竖向完全覆盖。j|k，只考虑一位，表示jk在该行两个位置都是0，即j和k的该位在该行上没有被捅，那么i-2行也必然没有捅出去，也就是说jk的该位在该行上没有格子(i-2不确定，可能被捅)；考虑所有位即所有行，如果某一位是0，就是上述情况；如果是1，说明j或k在该行上至少有一个位置有矩形。j|k的结果中，连续的0的个数必须是偶数个，否则不合法。这个结果并不是j或k的状态，而是二者按位或的状态，是“不存在的”，但它确实是一个n位二进制数，是一种可能的列状态，因此可以对其预处理。
// 3. 状态转移方程：f(i,j) = sum(f(i-1,k))，其中k满足上述两个条件

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

// M表示列属性，大小应为2^n，n为行数
const int N = 12, M = 1 << N;

int n, m;
int f[N][N];
bool st[M];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 逗号表达式，顺序执行每条语句，最后返回最后一个表达式的值
    // 本题为多组输入
    while (cin >> n >> m, n || m) {
        memset(f, 0, sizeof f);

        // 预处理状态是否合法，合法的状态存储在st数组中
        // 预处理的内容是上述第二条，即j|k=0的部分连续的0的个数必须是偶数个
        // 注意，代码只“枚举了一列”，其实是枚举了列的所有可能状态，所有列都是一样的
        // 通过枚举所有列的可能状态，把不满足的j记为st[j]=false
        // 枚举所有列状态
        for (int i = 0; i < 1 << n; i++) {
            // 先设为合法状态
            st[i] = true;
            // 统计连续的0的个数
            int cnt = 0;
            // 枚举i的每一位
            for (int j = 0; j < n; j++) {
                // 取出i的第j位。每个二进制数i共n位
                // 要熟悉这个枚举所有二进制数并且取出每一位的写法
                if (i >> j & 1) {
                    // 按位与：0101 & 0011 = 0001，即 5 & 3 = 1
                    // 如果第j位是1，且前面统计的连续0的个数是奇数个，那么这个状态不合法
                    // x & 1 结果为1表示x是奇数，结果为0表示x是偶数
                    if (cnt & 1) {
                        st[i] = false;
                    }
                    cnt = 0;
                } else {
                    cnt++;
                }
            }
            // 最后一段连续的0
            // 如果从中间某数开始到结尾没有遇到1，即没有进入if (i >> j & 1)的条件，那么就会一直统计连续0的个数，直到j=n-1结束循环。在此期间没有判断st合法的手段，因此需要在循环结束后再判断一次
            // 这种代码设计也是很常见的
            if (cnt & 1) {
                st[i] = false;
            }
        }

        // 第一列下标为0，f[0][0]表示第一列的任意行不含有横向放置的第二块，这种情况只有一种方案。本来第一列就只能作为起点，即放置横向矩形的第一块。
        // 这种“逻辑上的推导”常作为dp初始化条件的设定依据
        f[0][0] = 1;
        // 枚举所有列，枚举内容和上面的预处理不同。上面是枚举列的所有可能并拿出每一位，这里是枚举题设的列数m，然后枚举每列可能的状态j
        for (int i = 1; i <= m; i++) {
            // 枚举第i列的所有状态j
            for (int j = 0; j < 1 << n; j++) {
                // 枚举第i-1列的所有状态k
                for (int k = 0; k < 1 << n; k++) {
                    // 两个条件在题目上方已经阐释过了
                    // st[M]存储了列的所有可能状态的合法与否
                    // j|k会得到一个与二者无关的列状态，但通过这个状态可以判断其中连续0个数的合法性，进而判断j和k的合法性。不要试图认为j|k是j或k的反映，它只是个工具人，用来反映jk相邻两列的合法性的
                    if ((j & k) == 0 && st[j | k]) {
                        f[i][j] += f[i - 1][k];
                    }
                }
            }
        }
    }

    // 最后一列不应当捅出去(即横向放置的第一块)，这才是合法状态
    // 注意下标，最后一列为m-1
    // 最后一列不捅出去，那最后一列的下一列就不会被捅(即横向放置的第二块)，因此最后一列的状态为0
    cout << f[m][0] << endl;

    return 0;
}
