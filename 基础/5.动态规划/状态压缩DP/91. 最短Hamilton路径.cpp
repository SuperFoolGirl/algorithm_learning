// 给定一张n个点的带权无向图，从0编号，求起点0到终点n-1的最短Hamilton路径长度
// Hamilton路径是指不重不漏访问每个点恰好一次的路径。

// 第一行输入n，接下来n行每行n个数，表示图的邻接矩阵

// 状态表示
// f(i,j)表示所有从0走到j，走过的所有点是i的所有路径
// i是个二进制数，每一位表示一个点

// 状态计算
// 根据倒数第二个点进行分类，可能是0~n-1
// 那么每一类如何来求呢？
// 设已走过的点集为i，倒数第二个点为k，路径为0->...->k->j，那么f(i,j)=f(i-{j},k)+w[k][j]，k满足k在i中且k和j之间有边
// 这种通过不断从倒数第二步往前推的方式来求解路径问题的思路是很常见的

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

// N表示点数，M表示状态数
const int N = 20, M = 1 << N;

int n;
int w[N][N];
int f[M][N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> w[i][j];
        }
    }

    // 其他状态初始为正无穷
    memset(f, 0x3f, sizeof f);
    // 从0走到0，走过的点集是{0}，表示为1，路径长度为0
    f[1][0] = 0;

    for (int i = 0; i < 1 << n; i++) {
        for (int j = 1; j < n; j++) {
            // 从0走到j，走过的点集是i，那么j必须包含于i中
            // 提取二进制数i从右往左数第j位的值，为1表示j在i中，为0表示j不在i中
            if (i >> j & 1) {
                // j在i中，那么就枚举倒数第二个点k，k必须在i中且k和j之间有边
                for (int k = 0; k < n; k++) {
                    // i-(1<<j)表示从i中去掉j这个点，得到的状态是i-(1<<j)
                    // 点的状态表示是从右到左的，即二进制数从低位到高位
                    // 若i为1111，j为2(第三个点)，则i-(1<<j)就是1111-0100=1011，即去掉了第三个点
                    // 然后，要取出第k位。若k为1，说明k在i中；若k为0，说明k不在i中或k与j相同
                    // 注意一个误区，图是无向图，点编号的顺序与路径无关。例如k是j的前一个点，但k的编号可能比j大
                    // 很重要的一点是理解动态规划循环的枚举。我们在这里是枚举了所有可能的状态。如j，枚举所有可能的终点；如k，枚举所有可能的倒数第二个点
                    if (i - (1 << j) >> k & 1 && w[k][j]) {
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);
                    }
                }
            }
        }
    }

    // 走过所有点，终点为n-1
    cout << f[(1 << n) - 1][n - 1] << endl;

    return 0;
}
