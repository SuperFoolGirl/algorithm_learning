// 给定两个长度分别为n, m的字符串a, b，求既是a的子序列又是b的子序列的最长公共子序列的长度

// f(i,j)状态表示：
// 集合：所有出现在第一个序列的前i个字母，且出现在第二个序列的前j个字母的公共子序列的集合
// 属性：在f(i,j)表示的集合中，最长公共子序列的长度
// 两个字符串的问题，都可以用这种模式

// 状态计算：
// 对于两个字符串a,b,各自的字符遍历到a[i],b[j]
// 集合划分：a[i],b[j]分别选或不选，一共四种情况：00，01，10，11
// 先讨论两种简单的情况
// 00：f[i-1][j-1]
// 11：f[i-1][j-1] + 1。这种情况的前提是a[i]==b[j]
// 00和11的情况比较好理解，01和10的情况比较麻烦，下面是对这两种情况的分析
// 01：f[i-1][j]
// 10：f[i][j-1]
// 看似这么表示，实则不对。以01为例，f[i-1][j]的含义是公共子序列在a的前i-1个字母中，且在b的前j个字母中。这个状态的定义并没有限制b[j]是否在公共子序列中，因此f[i-1][j]可能包含b[j]，也可能不包含b[j]。
// 但是，01的需求是，一定要包含b[j]。因此，f[i-1][j]的定义范围超出了01的需求范围。10同理。
// 如果f[i-1][j]越界的部分在题目要求之外，那就可能得不到正确结果；但所幸分析后发现，f[i-1][j]越界的部分，其实在题目范围之内
// 那这样的话，就是集合划分的“不重”问题了，这里求最值可以重复

// 但我们会发现，上述f[i-1][j]和f[i][j-1]超出范围表示的那部分，其实等价于f[i-1][j-1]
// 由于属性是max，以f[i-1][j]为例，不管是00占上风还是01占上风，结果上总会被max选出来较大的那个
// 这也就是最值属性中，允许重复的原因
// 因此，00可以删掉，也可以保留。若把00删掉，与01和10的情况合并成f[i-1][j]和f[i][j-1]
// 最终状态转移方程：f[i][j] = max(f[i-1][j], f[i][j-1]) + (a[i]==b[j] ? 1 : 0)

// 用集合划分的视角来审视状态转移方程，会相对直观一些

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int a[N], b[N];
int f[N][N];
int n, m;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> m;
    // 注意输入的字符串是以1为起始的，0位置可以当作哨兵，方便状态转移方程的书写
    // 因为方程中出现了i-1和j-1，所以需要保证i-1和j-1不越界，0位置的哨兵就起到了这个作用
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    for (int i = 1; i <= m; i++) {
        cin >> b[i];
    }

    // 为了不越界，枚举i和j的范围是[1, n]和[1, m]，而不是[0, n-1]和[0, m-1]
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            // 00 10 01
            f[i][j] = max(f[i - 1][j], f[i][j - 1]);
            // 11
            if (a[i] == b[j]) {
                f[i][j] = max(f[i][j], f[i - 1][j - 1] + 1);
            }
        }
    }

    cout << f[n][m] << endl;

    return 0;
}
