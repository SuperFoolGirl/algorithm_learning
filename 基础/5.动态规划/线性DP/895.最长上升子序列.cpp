// 给定一个长度为n的数列，求数值严格单调递增的子序列的长度最长是多少
// 子序列定义：从一个序列中删除一些元素（也可以不删除）得到的序列叫做原序列的子序列
// 也就是说，子序列不一定由连续元素组成
// 例如：1,2,3,4,5是一个数列，1,3,5是它的一个子序列，2,4也是它的一个子序列，1,2,3,4,5也是它的一个子序列

// 状态表示：f(i)表示所有以i结尾的上升子序列
// f(i)的值：以i结尾的上升子序列的长度最长是多少(属性)

// 状态转移方程思路：
// 通过背包问题的学习，我们知道，要拆成若干个子问题来考虑状态转移方程

// 总体分为两种情况：
// 一、当前数小于等于前一个数，无法构成上升子序列：s[i] <= s[i-1]
// 这种情况下，f(i) = 1，因为以i结尾的上升子序列只能是s[i]本身。这种情况写在初始化里即可
// 二、当前数大于前一个数，可以构成上升子序列：s[i] > s[i-1]
// 对于f(i)表示的所有子序列中的倒数第二个数，一共有i种情况：
// 1. 空序列
// 2. 序列的第一个数
// 3. 序列的第二个数
// ...
// i. 序列的第i-1个数

// 因此，状态转移方程可以写成：
// f(i) = max(f(j)) + 1, 其中j的范围是[0, i-1]且s[j] < s[i]
// 代码：
// for (int i = 1; i <= n; ++i) {
//     f[i] = 1; // 初始化，当前数本身可以构成一个长度为1的上升子序列
//     for (int j = 0; j < i; ++j) {
//         if (s[j] < s[i]) { // 如果s[j]小于s[i]，说明可以构成上升子序列
//             f[i] = max(f[i], f[j] + 1); // 更新f[i]的值，取最大值
//         }
//     }
// }

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n;
int s[N], f[N];
int g[N];  // 记录转移路径，回顾图论fa数组

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> s[i];
    }

    for (int i = 1; i <= n; ++i) {
        for (int j = 0; j < i; ++j) {
            if (s[j] < s[i]) {  // 如果s[j]严格小于s[i]，说明可以构成上升子序列
                if (f[i] < f[j] + 1) { // 更新f[i]的值，取最大值。写法上有点像松弛操作
                    f[i] = f[j] + 1;
                    g[i] = j; // 记录转移路径，回顾图论fa数组
                }
            }
        }
    }

    // 求f数组中的最大值，即为最长上升子序列的长度。缓存为f[k]
    int k = 0;
    for (int i = 1; i <= n; i++) {
        if (f[i] > f[k]) {
            k = i;
        }
    }

    // 输出转移路径，共f[k]个数，路径为k, g[k], g[g[k]], ..., 直到g[g[...g[k]...]] = 0
    while (k) {
        cout << s[k] << " ";
        k = g[k];
    }

    return 0;
}
