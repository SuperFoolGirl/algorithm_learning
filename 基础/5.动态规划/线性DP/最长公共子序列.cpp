// 897
// 状态表示：所有出现在第一个序列的前i的字母，且出现在第二个序列的前j的字母的公共子序列
// 两个字符串的问题，都可以用这种模式
// 对于两个字符串a,b,各自的字符遍历到a[i],b[j]
// 集合划分：a[i],b[j]分别选或不选，一共四种情况：00，01，10，11
// 00：f[i-1][j-1]
// 11：f[i-1][j-1] + 1。这种情况的前提是a[i] == b[j]
// 01：f[i-1][j]
// 10：f[i][j-1]
// 注意，01和10的情况，虽然完全包含于f[i][j]，但其本身要超出状态表示的范围
// 比如f[i-1][j]可能不含b[j]
// 因此，00可以直接去掉，因为00包含在01和10当中了

// 由于本题的属性是最大值，因此上述的范围问题可以无视
// 这是个很感性的问题
// 以01和b[j]为例：
// f[i-1][j]保证字符串里一定没有a[i]，但可能有b[j]，也可能没有b[j]
// 这种情况完全覆盖了f[i-1][j-1]
// 换句话说，设f[i-1][j-1]为a，理想中01的状态为b，f[i-1][j]为c
// c实际上是max(a, b)，所以说“超出了状态标识的范围”
// 但是不要理解为是数量的相加，f[i-1][j]并不是两种情况的加和，而是两种情况中的最大值。初学时很容易被“相加”干扰
// 而c又参与了f[i][j]中max的计算，所以上述合并是完全合理的