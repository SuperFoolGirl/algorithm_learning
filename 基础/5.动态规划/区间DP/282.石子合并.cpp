// 设n堆石子排成一排，编号为1~n，第i堆石子有s[i]个。每次只能合并两堆石子，合并的代价是两堆石子数量之和。求把所有石子合并成一堆的最小代价

// 状态表示：
// 集合：f[i,j]表示所有将 第i堆石子到第j堆石子 合并成一堆石子的方式。则答案为f[1,n]
// 注意到，区间dp的状态表示是以区间为基础的，因此状态表示中的i和j分别代表区间的起点和终点
// floyd算法就是状态压缩后的区间dp
// 属性：min
// 状态计算：
// 最后一步，一定是两堆合并为一堆（区间内的石子要两两合并），即f[i,k]和f[k+1,j]合并成f[i,j]，其中k为分割点
// 但是k有若干种情况，需要枚举；因此，状态转移方程需要在所有k中取最小值
// 状态转移方程：f[i,j] = min(f[i,k] + f[k+1,j] + s[j] - s[i-1])，其中k为分割点，s为前缀和，表示最后一步的代价
// k范围 [i,j-1]，保证两边至少各有一堆石子 (f[i][i]和f[j][j]表示区间内只有一堆石子)

#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n;
int s[N];
int f[N][N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> s[i];
    }

    // 求前缀和，s[i]表示前i堆石子数量之和。这样，区间内石子数量之和就可以通过s[j] - s[i-1]来计算
    for (int i = 1; i <= n; i++) {
        s[i] += s[i - 1];
    }

    // 需要注意枚举顺序能够满足状态转移方程中f[i][k]和f[k+1][j]的计算。即保证在计算f[i][j]之前，f[i][k]和f[k+1][j]已经被计算出来了。
    // 因此，要按照区间从小到大枚举。因此最外层循环用len来控制区间，从2枚举到n
    // 第二层枚举起点i。由于区间长度确定，因此终点j也能确定，为i+len-1
    // 第三层枚举分割点k，范围为[i,j-1]，保证两边至少各有一堆石子
    for (int len = 2; len <= n; len++) {
        for (int i = 1; i + len - 1 <= n; i++) {
            // 起点确定，长度确定，因此终点也确定
            int j = i + len - 1;
            // 枚举分割点k，来求f[i][j]
            // 根据状态转移方程，此前f[i][j]没有算过，因此必须初始化为一个较大的数，保证后续的min操作能够正确更新
            f[i][j] = 0x3f3f3f3f;
            for (int k = i; k < j; k++) {
                f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);
            }
        }
    }

    cout << f[1][n] << endl;

    return 0;
}
