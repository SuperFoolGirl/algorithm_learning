#include <vector>
#include <algorithm>
#include <iostream>

class Solution
{
public:
    int rob(std::vector<int> &nums)
    {
        int n = nums.size();
        if (n == 0)
            return 0;                   // 处理空数组情况
        std::vector<int> mem(n + 1, 0); // 动态创建记忆数组，避免固定大小的限制
        return dfs(0, nums, mem);       // 这里传参为0是考虑了下标。nums[0]是第一个房屋的金额
    }

    int dfs(int x, std::vector<int> &nums, std::vector<int> &mem)
    {
        // 出口
        if (x >= nums.size())
            return 0; // 如果当前房屋索引 x 大于等于数组 nums 的长度，说明已经越界，没有房屋可偷，返回 0

        // 记忆化检查
        if (mem[x])   
            return mem[x];

        // 最关键的点就是状态转移方程
        // 状态转移：对于第 x 个房屋，有两种选择：
        // 不偷第 x 个房屋，那么最大金额就是从第 x + 1 个房屋开始能偷到的最大金额，即 dfs(x + 1, nums, mem)。 
        // 偷第 x 个房屋，那么就不能偷第 x + 1 个房屋，最大金额就是从第 x + 2 个房屋开始能偷到的最大金额加上第 x 个房屋的金额，即 dfs(x + 2, nums, mem) + nums[x]。 
        // 这里别忘了sum参数，也就是mem数组，到底记录的是什么
        // mem数组记录的是从第 x 个房屋开始能偷到的最大金额，因此x下标越大，对应的值理应越小。数组首元素显然应该是最大值
        // 取这两种选择中的最大值作为从第 x 个房屋开始能偷到的最大金额。 

        // 传参dfs(0)，就是从第一个房屋开始能偷到的最大金额
        // 熟悉一下这种搜索顺序，才能更好地体会到状态转移方程的含义

        // 关于状态转移方程的参数
        // 不宜过多，尽量只包含必要的参数。相比普通的参数，这种题目的参数比较有韵味
        int sum = std::max(dfs(x + 1, nums, mem), dfs(x + 2, nums, mem) + nums[x]);

        // 记忆化存储
        mem[x] = sum;

        // 返回从第 x 个房屋开始能偷到的最大金额
        return sum;
    }
};



// 递，自顶向下
// 归，自底向上
// dfs = 递归

// 记忆化搜索 = 暴力dfs + 记录答案
// 递推公式 = dfs向下搜索的递推公式，也就是状态转移方程
// 递推数组的初始值 = dfs递归的边界

// 动态规划有两种实现方法
// 1.递归 + 记忆化搜索。 利用递归的方式遍历问题的解空间，同时使用额外的数据结构（如数组或哈希表）来记录已经求解过的子问题的结果，避免重复计算
// 2.递推公式 + 递推数组  动态规划的一个重要目标是避免重复计算子问题，而递推正是实现这一目标的有效方式。通过记录子问题的解，并按照一定的顺序依次计算，后续的子问题可以直接利用前面已经计算好的结果

// 我们在写递归也就是dfs的时候，是把小问题给递出去，然后归回来的时候出答案
// 而改写成循环用递推公式的时候，是直接从小问题出发，一步步推到大问题，最后得到答案。给出递推初始条件和公式就可以开始递推，这一点是符合数学直觉的。
// 虽然得到答案的逻辑顺序是一样的，但是写法上是相反的
// 因此实际的转移方程逻辑虽然一样，但写法可能有不同
// 此外，由于写法相反，递推不需要记忆化，因为递推是从小问题推到大问题，不会重复计算，而递归是从大问题分解到小问题，会重复计算，因此需要记忆化


// 下面演示本题改为递推的写法
// 这里f递推数组的含义是，从前i个房屋开始能偷到的最大金额(0-i)
// 而之前的mem数组的含义是，从第i个房屋开始能偷到的最大金额(i-n)
// 从这里去体会递推与递归写法相反这一事实

// int f[1000]; // 递推数组
// f[0] = nums[0], f[1] = max(nums[0], nums[1]); // 起始条件
// for (int i = 2; i < n; i--) // 注意范围  这里是顺序递推
// {
//     f[i] = max(f[i - 1], f[i - 2] + nums[i]); // 状态转移方程中加号变为减号，是递归改为递推中方程的变化
// }
// return f[n - 1]; // 返回最后一个房屋的金额

// 对于递推的写法，可以进一步压缩空间
// 回忆斐波那契数列的递推写法，只需要两个变量，不需要数组
// 不过初学阶段数组更直观，因此这里还是用数组


// 刚才有提到过，状态方程是最困难的一步
// 而状态方程与函数参数等变量息息相关，因此变量含义的确定也是一件重要的事情
// 例如上个题中，mem数组和f数组的含义就不同，因此状态方程也不同
// 多做题形成题感，才能更好地根据递推和递归的顺序不同，初始化更加合理的数组和变量