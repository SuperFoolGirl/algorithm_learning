// 以01背包为例，状态转移方程中，f(i)只用到了f(i-1)，没有涉及f(i-2)等，因此可以用滚动数组来降维
// 方程：f(i,j) = max(f(i-1,j-V[i]) + W[i], f(i-1,j))
// 降维后：f(j) = max(f(j-V[i]) + W[i], f(j))

// j原先是从小到大枚举的，也就是说，f(j-V[i])的计算必然会早于f(j)
// 如果j依然从小到大遍历，f(j-V[i])的结果就是本轮的，即f(i,j-V[i])
// 但我们想要的是f(i-1,j-V[i])

// 外层循环i标识着轮数。由于是滚动数组，每进入新的一轮，f(j)的结果都会被覆盖
// 那么，在f(j-V[i])没有被覆盖之前，即等价于原先的f(i-1,j-V[i])，就是我们想要的结果
// 因此，内层j循环改为从大到小，确保计算f(j)时，f(j-V[i])还未被计算，新结果还没将其覆盖，其保存着上一轮的结果
// 循环中用到的数据f从m到v[i]，而用于计算的f从m-v[i]到0，互不干扰，新得到的结果不会用于新计算。因此直到循环结束为止，不会产生脏数据的可能
// 而对于分段函数的另一段——f(i,j)=f(i-1,j)，与上面j错位不同，这里j相同，可以直接省略掉

// 总结：滚动优化的前提是转移方程只跨一层，能够使空间复杂度降低一个数量级。当然，这样一来只能得到最终结果，无法获取中间状态了
// 这里提到的只跨一层，指的是i相差1，j不同；如果j相同，即f(i,j)与f(i-1,j)，二者是直接相等的，毕竟这就是滚动数组的本质

#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, m;
int v[N], w[N];
int f[N];    // 降去i这一维

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> v[i] >> w[i];
    }

    for (int i = 1; i <= n; i++) {
        for (int j = m; j >= v[i]; j--) {    // 顺序倒置
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }

    cout << f[m] << endl;
    return 0;
}
