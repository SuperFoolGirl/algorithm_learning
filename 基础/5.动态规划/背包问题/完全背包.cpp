// 相比01背包，物品的使用次数不限

// 从状态表示和状态计算角度来考虑完全背包问题
// 首先，状态表示和01背包一样。属性也还是最大值
// 状态计算，对集合的划分不同了。一个物品可以使用多次，因此可以把集合划分为k个部分
// 第i个物品选0次、1次、2次、3次...k次
// 因此，最朴素的状态转移方程为：
// f(i,j) = max(f(i-1,j), f(i-1,j-k*v[i])+k*w[i])，其中k*v[i] <= j

// 当然，这是可以优化的，观察下面两个式子
// f(i,j)   = max(f(i-1,j), f(i-1,j-v)+w, f(i-1,j-2v)+2w, f(i-1,j-3v)+3w, ...)
// f(i,j-v) = max(          f(i-1,j-v),   f(i-1,j-2v)+w,  f(i-1,j-3v)+2w, ...)
// 其中，将2式加w，就得到了1式的右边部分。用2式来取代1式的右边部分即可。
// 因此，可以得到状态转移方程：
// f(i,j) = max(f(i-1,j), f(i,j-v)+w)，与01背包区别在于第二项的参数1不再是i-1，而是i

// 01背包都是从i-1转移过来的，而完全背包要从i转移过来
// 但完全背包也可以降维
// 而且，完全背包不需要内层循环倒置。这点可以通过状态转移方程来理解
// 我们想要的就是更新过的，正中下怀

// 抛开数学角度，从逻辑角度来考虑
// f(i,j)的含义是前i个物品，容量为j的最大价值
// 单看这个式子，结合这个定义，也是十分合理的

// 下面提供滚动数组优化版本
#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, m;
int v[N], w[N];
int f[N];    // 降去i这一维

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> v[i] >> w[i];
    }

    for (int i = 1; i <= n; i++) {
        for (int j = v[i]; j <= m; j++) {    // 顺序无需倒置
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }

    cout << f[m] << endl;
    return 0;
}
