// 相比01背包，物品的使用次数不限
// 为什么01背包的状态转移方程是两段的分段函数？因为每一个物品只有选或不选两种情况
// 而完全背包问题，每一个物品可以选0次、1次、2次...k次，因此状态转移方程就有了多段的分段函数
// 注意，这是重点！好好体会状态转移方程是怎么写出来的！
// 下面其实也展示了将多端函数联立的过程

// 从状态表示和状态计算角度来考虑完全背包问题
// 首先，状态表示和01背包一样。属性也还是最大值
// 状态计算，对集合的划分不同了。一个物品可以使用多次，因此可以把集合划分为k个部分
// 第i个物品选0次、1次、2次、3次...k次
// 因此，最朴素的状态转移方程为：
// f(i,j) = max(f(i-1,j), f(i-1,j-k*v[i])+k*w[i])，其中k*v[i] <= j

// 当然，这是可以优化的，观察下面两个式子
// f(i,j)   = max(f(i-1,j), f(i-1,j-v)+w, f(i-1,j-2v)+2w, f(i-1,j-3v)+3w, ...)
// f(i,j-v) = max(          f(i-1,j-v),   f(i-1,j-2v)+w,  f(i-1,j-3v)+2w, ...)
// 其中，将2式加w，就得到了1式的右边部分。用2式来取代1式的右边部分即可。
// 因此，可以得到状态转移方程：
// f(i,j) = max(f(i-1,j), f(i,j-v)+w)，与01背包区别在于第二项的参数1不再是i-1，而是i
// 基于这个式子，讨论滚动数组优化
// 首先，明确一下f(i,j)=f(i-1,j)是降维滚动数组固有的性质，而原式的第二项根本没有i差一位，也就是不涉及滚动数组的脏数据，不需要倒序遍历
// 模拟验证一下也可知，不涉及脏数据的问题。f[0~v[i]]
// 因此直接写成f(j)=max(f(j), f(j-v)+w)即可

// 抛开数学角度，从逻辑角度来考虑
// f(i,j)的含义是前i个物品，容量为j的最大价值
// 单看这个式子，结合这个定义，也是十分合理的

// 下面提供滚动数组优化版本
#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int n, m;
int v[N], w[N];
int f[N];    // 降去i这一维

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        cin >> v[i] >> w[i];
    }

    for (int i = 1; i <= n; i++) {
        for (int j = v[i]; j <= m; j++) {    // 顺序无需倒置
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        }
    }

    cout << f[m] << endl;
    return 0;
}
