1. 二维dp数组优化为一维滚动数组，逆序遍历背包，不引入辅助数组

(1) dp[i][j] 只与 dp[i - 1][j] 和 dp[i - 1][j - v[i]] 有关，也就是只与上一层（i - 1）的状态有关。
(2) 为了将二维数组 dp[i][j] 优化为一维数组 dp[j]，我们需要确保在更新 dp[j] 时，使用的是上一层的状态。具体来说，在更新 dp[j] 时，我们要保证 dp[j - v[i]] 还是上一层的值。为了实现这一点，我们需要逆序遍历背包容量 j

    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; j--)
            if (j >= v[i])
                dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
    cout << dp[m]; // 这个dp[m]是i=n那一层的，滚动数组随着最外层循环不断滚动

(3) 逆序遍历的目的是保证在更新 dp[j] 时，dp[j - v[i]] 还是上一层的状态。例如，当我们更新 dp[j] 时，dp[j - v[i]] 还没有被本次循环更新过，它仍然保存着上一层（即考虑前 i - 1 个物品时）的值，这样就可以正确地使用状态转移方程。
(4) 在逆序遍历中，当我们更新 dp[j] 时，由于 j 是从大到小递减的，j - v[i] 一定小于 j，并且在本次循环中还没有更新到 dp[j - v[i]]，所以 dp[j - v[i]] 仍然保存着上一层（只考虑前 i - 1 个物品）的状态。这样就能保证在更新 dp[j] 时，使用的 dp[j - v[i]] 是正确的上一层状态，从而正确模拟二维数组的状态转移过程。



2. 引入辅助数组，双数组复制法

    for (int i = 1; i <= ; i++)
    {
        for (int j = 0; j <= m; j++)
        {
            if (j < v[i])
                g[j] = dp[j];
            else
                g[j] = max(dp[j], dp[j - v[i]] + w[i]);
        }
        memcpy(dp, g, sizeof dp);   
    }

(1) if (j < v[i]) g[j] = dp[j];：如果当前背包容量 j 小于第 i 个物品的体积 v[i]，则不能选择第 i 个物品，所以 g[j] 直接继承 dp[j] 的值，这里的 dp[j] 保存的是考虑前 i - 1 个物品时容量为 j 的最大价值。
(2) else g[j] = max(dp[j], dp[j - v[i]] + w[i]);：如果当前背包容量 j 大于等于第 i 个物品的体积 v[i]，则可以选择第 i 个物品，需要在不选（dp[j]）和选（dp[j - v[i]] + w[i]）之间取最大值更新 g[j]。
(3) memcpy(dp, g, sizeof dp);：在完成对当前物品 i 的所有容量状态更新后，将临时数组 g 的值复制回 dp 数组，以便下一轮循环（考虑下一个物品）时使用更新后的状态。
(4) 在完成对当前物品 i 的所有容量状态的更新后，需要把当前轮的状态 g 复制到 dp 中，这样在下一轮循环（考虑下一个物品）时，dp 就能保存上一轮的状态，为后续的状态转移提供正确的数据。一直循环下去，最后就是答案
        