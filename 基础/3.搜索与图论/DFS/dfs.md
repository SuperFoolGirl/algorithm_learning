### DFS
- 可以模拟成栈，空间复杂度为$O(h)$，$h$为树的高度
- DFS无法像BFS一样，保证找到的路径是最短的。
- 适用场景：不涉及“最小”“最短”等题目描述，或者看起来比较“怪异”
- 涉及两个概念：**回溯**和**剪枝**。
  - 回溯：回溯是递归返回的自然状态，借助递归的返回，可以进行一些标记工作，来实现回溯
  - 剪枝：在搜索过程中，提前排除一些不可能的路径，以减少搜索的空间和时间复杂度。
#### 代码思路
```c++
void dfs(int x) {
    // 递归终止条件
    if (/* 结束条件 */) {
        // 处理结果，如打印
        for (auto t : res) {
            cout << t << " ";
        }
        cout << endl;

        return;
    }

    // 剪枝，形式上与递归终止类似
    // 如果能在没有抵达终止条件前，判断出当前状态不可能满足条件，就可以提前结束搜索
    if (/* 剪枝条件 */) {
        return;
    }

    // 选择下一个扩展搜索目标
    for (/* 遍历选择 */) {
        // 回溯依赖于状态标记。假设有st数组来标记状态
        // res数组用来记录搜索过程中需要存储的信息，每一步搜索都需要更新当前的状态，因题目而异
        if (!st[i]) {
            // 进入下一层之前，改变现场
            st[i] = true;
            res[x] = i;   // 回溯后可再次覆盖，不需要恢复现场

            dfs(x + 1);

            // 回溯后，恢复现场
            st[i] = false;
        }
    }
}
```