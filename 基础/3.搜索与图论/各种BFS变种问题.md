对于广度优先搜索，一般都要配备vis数组

有的时候，是**入队前判断vis**，有的时候是**出队后判断vis**

入队前判vis：队列循环前置vis[起点]=true，扩展时判断扩展点是否访问过，没访问过才入队并标记vis

出队后判vis：仅在出队之后、扩展之前判断vis，没访问过才扩展并标记vis

**这里先给结论：对于普通bfs(边权0/1)，入队前判bfs；对于带权bfs，出队后判vis**

补充一点，入队前判bfs效率更高，避免了重复入队；**对于普通bfs来说，两种方法皆可**，但显然选择效率更高的

下面解释下原因：

入队前判vis：首次入队的路径就是最短路径，无需多次入队，提前标记可避免重复入队

出队后判vis：同一节点可能被多次入队（不同路径的代价不同），但只有首次出队（代价最小的那次）是有效解，后续出队的同节点可直接跳过。

后者有些抽象，这里举一个例子：

对于目标点v，通向它的路有多条，总距离各不相同。

对于bfs的扩展方式来看，路径上结点数少的，会先达到v（因为bfs是一层层扩展的），但我们假设，虽然结点少，但边权大，导致总距离反而更大。

而路径上结点数多的，虽然会晚一些达到v，但边权小，总距离反而更小。

如果第一次访问到v时就标记vis，那么后续那些总距离更小的路径就无法被考虑到。

而优先队列天然可以维护一个“最小总距离优先”的顺序，因此可以保证当我们第一次从队列中取出v时，它对应的路径就是总距离最小的路径。

这就是代码 `if (dist > d[node]) continue;` 的意义

而对于不止涉及距离的问题，其他变种权值也可以用类似的考虑方式

而对于终点剪枝问题，也是类似的：

入队前判vis：push前，直接检查是否为终点，是则返回

出队后判vis：pop后，直接检查是否为终点，是则返回