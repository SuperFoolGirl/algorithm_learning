// 在开始之前，我需要简单聊一下映射这个话题
// 数组是最基本的映射，键值对关系为：int->其他基本类型
// 哈希表是较为高级的映射，键值对关系为：任意类型->任意类型
// 映射的作用是用来查找。比如我们经常定义二维数组对题目中的地图进行映射，这样我们可以通过坐标来查找地图上的元素
// 结构体则是用来储存数据的，本身没有映射的功能
// 不过，结构体和pair可以作为映射的键值对，毕竟哈希表是任意类型。但作为键的话，需要自己提供哈希函数等多余操作
// 为什么会想到结构体等类型做映射的键值对？因为我们想要储存一个点的多个信息
// 那么，用更简单的方式，可以多创建几个二维数组。分别储存这些信息
// 这一点之前是无意中用到的，比如map，vis，dist等等
// 可以视为是用空间换时间的一种方式
// 但这个题其实还有一个问题
// 映射关系是一一对应的

// -----------------------------------------------------------------------------------------------------------------
// *此前我没接触过三维数组，对bfs的固有理解是不足的
// 因此下方双注释内容理解有一些缺陷
// 比如dist数组采用三维数组，意味着只要朝向不同，一个点可以被多次走
// 但这不影响bfs的固有性质：先到达的点一定是最短路径

// // 但这个题目中，一个点的不同朝向都会被放进队列，这样就没法用坐标来映射朝向和步数了(我想写一个unoredered_map<pair<int, int>, pair<int, int>>)
// // 所以只能投机取巧了。for循环里，让前三个点跑图，从原点扩展出去
// // 后面两个点旋转，留在原地不动。
// // 由于bfs的特性，最先到达的点一定是最快的，后面再到达这个点，需要的步数一定更多
// // 那么，如果没转向的路径下，达到a点并记录在dist数组中，那么转向的路径下，a点一定不会被再次访问
// // 因此，队列需要维护的数据只有三个：坐标和朝向。步数是不用管的，交给dist数组
// // 为什么要维护朝向？已经提到了，每个坐标会映射多个朝向，所以必须将朝向作为一个属性来考虑，将其入队，而不能用映射关系来维护
// // dist数组刚才提到了，鉴于其特性，所以可以用线性表来映射，而非作为一个属性来维护
// // 所以。用结构体来维护这三个数据。我们也不需要检索，访问这些数据时，访问对象都是拿出来的队首t，根本不需要映射
// // 朝向face是每个点的属性，当然得写成结构体里的变量，自然不是全局变量
// -----------------------------------------------------------------------------------------------------------------

// 由于每个点有了三个属性，所以部分其他映射关系，如dist数组，也要改成三维。这一点没接触过。
// 我定义的映射关系有两个：dist和room。其中room是静态的，仅记录坐标与障碍物的关系；但dist是动态的，是搜索过程中的记录，其映射与朝向这个维度也有关系，所以需要改成三维

// 这里可以多讲一点，多维数组的映射关系
// n维数组，意味着n个属性一起映射一个值，可以简单理解为一个函数有n个参数
// 千万别把n维数组和几何联系起来，自讨苦吃
// n维数组的作用是，可以在键都是非负整数的情况下，简单地写出映射模型，而不用unordered_map然后自己再写个哈希函数
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
#define MAXN 55

// 每个点的朝向需要存 因此改用结构体。
struct Node
{
    int x, y, face;
} Start; // 这段代码做了两件事：1.定义了一个结构体类型Node 2.定义了一个Node类型的变量Start

int n, m;
int room[MAXN][MAXN];
// 从南开始，顺时针写
// 我们的方向数组中没有原地不动，但数据会给出入口相同的情况。。所以要特判
// 但我们有转向的代码判断，在那里加入return即可；也可以直接在main里特判然后直接return 0
// 这里只是提醒一下，不要忘了这个特判。只有一两个案例过不去的话，大概率就是这些边界问题
int dx[4][3] = {{1, 2, 3}, {0, 0, 0}, {-1, -2, -3}, {0, 0, 0}};
int dy[4][3] = {{0, 0, 0}, {-1, -2, -3}, {0, 0, 0}, {1, 2, 3}};
// dist可以取代vis数组，不过这个题很特殊，转向也占用时间，因此dist的功能要放到结构体中
int dist[MAXN][MAXN][4];
queue<Node> q;
pair<int, int> End;

bool obstacle(int x, int y, int step, int face)
{
    // 格子对应的格点是左上角坐标
    // 走到了一个格点，走到的是这个格子的左上角，但这个点有可能是障碍物的左下角
    for (int i = 0; i < step + 1; i++)
    {
        if (room[x + dx[face][i]][y + dy[face][i]] == 1) // 这个格子本身是障碍物，走到了左上角格点
            return true;
        if (room[x - 1 + dx[face][i]][y + dy[face][i]] == 1) // 这个格子本身不是障碍物，但这个格子对应的格点是障碍物的左下角格点
            return true;
        if (room[x + dx[face][i]][y - 1 + dy[face][i]] == 1) // 这个格子本身不是障碍物，但这个格子对应的格点是障碍物的右上角格点
            return true;
        if (room[x - 1 + dx[face][i]][y - 1 + dy[face][i]] == 1) // 这个格子本身不是障碍物，但这个格子对应的格点是障碍物的右下角格点
            return true;
    }
    return false;
}

// 这个题要求求最短路径，dfs的特性就是先到的点一定是最短路径，所以别硬套二分啊
int bfs()
{
    memset(dist, -1, sizeof dist);

    q.push(Start);
    dist[Start.x][Start.y][Start.face] = 0;

    while (!q.empty())
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 5; i++)
        {
            if (i < 3)
            {
                int a = t.x + dx[t.face][i];
                int b = t.y + dy[t.face][i];

                if (a <= 0 || a > n - 1 || b <= 0 || b > m - 1) // 机器人不能看成质点
                    continue;
                if (dist[a][b][t.face] != -1)
                    continue;
                // 由于存在跨步，所以要判断中间的点是否有障碍物。由于越界判断已经写了，所以这一步必然不会越界
                // 这题最逆天的一点在于，机器人在格点上走，而不是在格子上走。所以障碍物一圈的格点都不能走
                // 而且，第一行和第一列也不能走，因为这里的格点超出了地图范围。
                // 题目一开始就说 机器人不能看成质点。。不过这个题也是真的逆天
                // 坐标表示是去了左上角，所以要求左下、右上、右下都不能踩
                if (obstacle(t.x, t.y, i, t.face))
                    continue;

                Node member = {a, b, t.face};
                q.push(member);
                dist[a][b][t.face] = dist[t.x][t.y][t.face] + 1;

                if (a == End.first && b == End.second)
                    return dist[a][b][t.face];
            }
            else
            {
                int new_face;
                if (i == 3) // 左转，小心出负数，不能用减法
                    new_face = (t.face + 3) % 4;
                else // 右转
                    new_face = (t.face + 1) % 4;

                // 这里也不能无脑入队，还是要结合dist数组的三个维度来判断
                // 我们肯定不能让一个点一直转圈啊！
                if (dist[t.x][t.y][new_face] != -1)
                    continue;

                // 转向操作占用时间，也需要dist记录
                dist[t.x][t.y][new_face] = dist[t.x][t.y][t.face] + 1;
                q.push({t.x, t.y, new_face}); // 可以直接这样写，不需要定义一个新的结构体变量
            }
        }
    }
    return -1;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            cin >> room[i][j];

    char input;
    cin >> Start.x >> Start.y >> End.first >> End.second >> input;

    // 特判
    if (Start.x == End.first && Start.y == End.second)
    {
        cout << 0;
        return 0;
    }

    switch (input)
    {
    case 'S':
        Start.face = 0;
        break;
    case 'W':
        Start.face = 1;
        break;
    case 'N':
        Start.face = 2;
        break;
    case 'E':
        Start.face = 3;
        break;
    }
    cout << bfs();
    return 0;
}