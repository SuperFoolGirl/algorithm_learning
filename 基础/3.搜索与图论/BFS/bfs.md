### BFS

- 可以模拟成队列，空间复杂度为$O(2^h)$，$h$为树的高度
- 优势：由于是层序扩展搜索，因此自带**最短路径**的性质，即BFS第一次访问到某个节点时，一定是最短路径。
- 劣势：相比DFS，占用空间大了很多
- 应用场景：适合用于求解“最小”问题
- 另外，DP可以看作是一种特殊的最短路问题

#### 代码模板

```c++
// 二维g数组存地图，二维d数组存从起点到当前点的距离。q为模拟队列
int g[N][N], d[N][N];
PII q[N * N];

// 初始化方向向量数组dx,dy。这里按顺时针方向来写
int dx[] = {-1, 0, 1, 0};
int dy[] = {0, 1, 0, -1};

// 可选：记录路径
PII pre[N][N];

int bfs() {
    // 自行模拟队列，并入队起点
    int hh = 0, tt = 0;
    q[0] = {0, 0};

    // 初始化距离，修改起点距离
    memset(d, -1, sizeof d);
    d[0][0] = 0;

    // 只有一个元素时，hh == tt。队列空时才允许退出
    while (hh <= tt) {
        // 取出队头
        auto t = q[hh++];

        // 遍历扩展方向
        for (int i = 0; i < 4; ++i) {
            // 计算新坐标
            int x = t.first + dx[i];
            int y = t.second + dy[i];

            // 在扩展前就进行一系列判断，对于不满足条件的，直接不允许入队
            // 而DFS则是先无脑往前走，递归到下一个函数后，通过终点/剪枝条件来判断是否回溯

            // 判断是否越界
            if (x < 0 || x >= n || y < 0 || y >= m) {
                continue;
            }

            // 判断是否访问过
            if (d[x][y] != -1) {
                continue;
            }

            // 更新距离
            d[x][y] = d[t.first][t.second] + 1;

            // 可选：记录路径
            pre[x][y] = t;

            // 入队
            q[++tt] = {x, y};
        }
    }

    // 假设地图为n行m列，返回终点（右下角）到原点的距离
    return d[n - 1][m - 1];
}



// 可选：输出路径
int x = n - 1, y = m - 1;
// 当x和y同时为0时，就回到了终点，结束。
while (x || y) {
    cout << x << " " << y;
    auto t = pre[x][y];
    x = t.first;
    y = t.second;
}
```