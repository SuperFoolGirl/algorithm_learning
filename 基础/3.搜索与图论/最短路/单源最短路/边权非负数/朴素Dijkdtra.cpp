// 仔细想一下，离散中的算法就是O(n^2)的复杂度
// 离散中，右边n-1列，其实就是dist数组。以第一轮为例，对于能和起点直接相连的，标为边权；否则为∞
// 所以函数里内层循环用d来打擂台是合理的
// 不过函数的第一次外部循环，是用来先完成上述内容：把与起点直接相连的点的距离更新到dist数组中
// 从第二轮外部循环开始，执行的就是与离散数学完全相同的逻辑

// 从1号点到其他各点的最短距离
// S集合：当前已确定的最短距离的点，参考离散

// 如果出现自环，则自环一定不会出现在最短路里
// 如果出现重边，则保留一条最短的即可（重边们的边权可能不同）

#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

// 邻接矩阵
int n, m;
int g[N][N];
int d[N];
bool st[N];

int dijkstra() {
    // 初始化距离
    memset(d, 0x3f, sizeof d);
    d[1] = 0;    // 再强调，起点1为题目给定的起点序号

    // 外层循环：每次循环都会确定一个点到起点的最短距离，也就是离散中列出n-1列，n-1个元素从S'全部转移到S
    // 这里给n次循环，因为第一次需要先把与起点直接相连的点的距离更新到dist数组中
    for (int i = 0; i < n; i++) {
        // t 变量用于存储当前找到的最近节点的索引。t = -1 表示当前还没有找到。
        int t = -1;
        // 内层循环：找到目前未确定的节点中（即S'），离起点最近的点。离散中也是从右边那n-1列中找到最小的
        for (int j = 1; j <= n; j++) {
            // t == -1 参与判断，是因为第一次无论如何都要选择一个点来进行比较
            // 然后就是擂台模型，遍历所有的j，找出最小的，然后用t来存储，再更新
            if (!st[j] && (t == -1 || d[j] < d[t])) {
                t = j;
            }
        }

        // 正如离散，每一轮都可以找到一个点添加到S，进而确定该点到起点的最短路
        st[t] = true;

        // 更新最短路距离。当前已经确定了d[t]，因此可以用它来更新其他点的距离，以t为中间点，往外延伸一条出去
        // 这里和离散完全相同。对于新插入的点，如果能以更短的距离，通过t到达其他点，就更新它们的距离
        // 不过对于第一次外部循环，这里是把与起点直接相连的距离更新到dist数组中
        for (int j = 1; j <= n; j++) {
            d[j] = min(d[j], d[t] + g[t][j]);
        }

        if (d[n] == 0x3f3f3f3f) {    // 终点不可达，则返回-1
            return -1;
        } else {
            return d[n];
        }
    }
}

int main() {
    cin >> n >> m;

    // 初始化邻接矩阵
    memset(g, 0x3f, sizeof g);
    for (int i = 1; i <= n; i++) {
        g[i][i] = 0;    // 自环的边权为0
    }

    while (m--) {
        int a, b, c;    // c为边权
        cin >> a >> b >> c;
        // 保留长度最短的边
        g[a][b] = min(g[a][b], c);
    }

    cout << dijkstra() << endl;

    return 0;
}
