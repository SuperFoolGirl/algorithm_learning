这里提供了两种常用的建树方法

其中，前序序列依赖idx（记录结点序号），父子边列表不依赖其他结构

和图论不同，图论的idx用于记录边，而二叉树的idx用于记录点
在前序序列建树中，idx=1的点为根结点

在父子边列表中，根结点的选择给了两种方式，可自行选择

在图论中，ne数组用于记录方向关系，在二叉树中用l和r直接连接点
总之，二叉树中没有对边进行处理，而是直接对点进行处理

fa数组在二者中都是可选的，其作用有二：
1. 快速找到父结点
2. 回溯路径，类似图论中pre数组的作用，毕竟前驱就是father

关于节点的值
1. 父子边列表：
   首先明确一个问题：节点编号和节点权值
   在图论中，node直接代表编号，h[node]可以访问node的第一条出边
   二叉树中，node也直接代表编号，和tr[node].val是一致的
   所以tr结构体不需要保留val字段
   在普通二叉树中，各点没有权值，都是1；如果有权值的话，可以给一个w字段，和图论中一样
   总结，如果节点值==节点编号，就没有必要开新字段
2. 前序序列：
   和父子边列表不同，这里节点值!=节点编号
   比如前序序列的第一个输入，编号是1，就是根结点，但它的值可以是随意，比如8
   这样，root = 1, tr[1].val = 8
3. 对于空结点，其只在tr[i]的l和r中体现，统一赋值为-1