// 邻接表适用于稀疏图
// 空间复杂度远低于邻接矩阵
// 邻接表访问边的时间复杂度为O(n+m)，对于边稀疏的情况，邻接表的效率会有所保障

// 邻接表用于存储有向图/无向图
// h[x] = y，表示x指向y
// 以h[x]为头结点的整个链表，里面的节点都是x的出边
// 内部的链表顺序与实际图无关

// 树是特殊的图，连通无环图
// 所以二者存储的方法是一致的

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

// N为链表个数，M为每个链表的最大长度
const int N = 1e5 + 10, M = N * 2;

// 参考哈希表-拉链法。h为所有点的集合，每个点拉出一条链表来
// idx是边的编号，h[点]存储idx来表示第一条出边，e[边]存储边指向的点，ne[边]存储该边同起点的下一条边
// 注意，ne数组含义与单链表不同。单链表的ne数组串联起整个单链表，而图的ne数组则不是。各个单链表是h数组分立的。
// 因此e[h[idx]]是常用的操作，获取第一条出边指向的点
// idx为边，h[点] = 边，e[边] = 点，ne[边] = 边；点的序号一般从1开始，边的序号idx一般从0开始
int h[N], e[M], ne[M], idx;

// 使用头插法，将b插到a的链表头，使得a指向b
// 强调一下，h[a]是a的出边构成的集合的头结点，类似兄弟节点的那种形式
// 头结点h[a]与后面的节点们是并列关系，他们都是a的出边，由a直接指向
// 因此这里头插法并没有特殊含义，只是惯例上这样操作，效率高。尾插的话由于没有维护尾结点，需要找下去，太慢了

// 如果是无向图，那就调用两次add，加入两条边
void add(int a, int b) {
    e[idx] = b;        // 开一条新边idx，指向b。下面要将该边的起点变成a
    ne[idx] = h[a];    // b取代原先的第一条出边h[a]，h[a]成为b的后继
    h[a] = idx++;      // 更新b为第一条出边，然后idx自增
}

int main() {
    // 让n个头结点全部指向-1
    memset(h, -1, sizeof h);
}
