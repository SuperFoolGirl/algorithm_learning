### 质数
#### 1. 质数的判定——试除法
##### 时间复杂度 $O(sqrt(n))$
```c++
bool is_prime(int n) {
    if (n < 2) {
        return false;
    }

    // n = 2 不会进入下面的循环，直接return true
    for (int i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
} 
```
#### 2. 分解质因数——试除法
##### 时间复杂度 $O(sqrt(n))$，最好为$O(\log n)$
> 从小到大尝试$n$的所有因数，枚举到$\sqrt{n}$即可
> $n$的质因子中，最多只有一个大于等于$\sqrt{n}$的；如果有两个及以上，那相乘就大于$n$了
```c++
void divide(int n) {
    for (int i = 2; i * i <= n; i++) {
        // 虽然i遍历的不是质数，但如果能进入判断，i一定为质数
        // 当枚举到i时，意味着此前的循环里，所有从2到i-1的所有质因子都除干净了
        // 那么，i的因数只有1和i，则i一定是质数
        if (n % i == 0) {
            // 分解质因数，一个数质因子可能有多次，这里要全除完
            int s = 0;
            while (n % i == 0) {
                n /= i;
                s++;
            }
            cout << i << " " << s << endl; // 输出当前质因子及其次数
        }
    }

    // 单独处理大于sqrt(n)的质因子——其实就是n，n是质数
    if (n > 1) { // 若n为1，无法质因数分解
        cout << n << " " << 1 << endl;
    }
}
```
#### 3. 生成质数——筛质数
> 注：实际做题时，一般用线性筛法
##### 埃氏筛法

###### 时间复杂度 $O(n\log\log n)$

> 对于给定的范围（从2开始），对范围中的所有数，从前到后依次删除其在范围中的所有倍数，最终剩下的就是质数。
> 对于剩下数中任意一个p，它没有被删，说明它不是2~p-1中的任何一个数的倍数，即2~p-1中没有p的因子，因此p一定是质数。
> 但是，可以**进一步优化**：
> 只删掉质数的倍数即可
```c++
void get_primes(int n) {
    for (int i  = 2; i <= n; i++) {
        // st[i] = false的i为质数，不过这里用primes数组来维护
        if (!st[i]) {
            primes[cnt++] = i;
            // 删掉质数的倍数
            for (int j = i + i; j <= n; j += i) {
                st[j] = true;
            }
        }
    }
}
```
##### 线性筛法（欧拉筛法）
> 当n的数量级达到$10^7$时，效率会明显高于埃氏筛法。下面讲原理
> 核心：合数n只会被最小质因子筛掉，避免了重复筛选
> 从小到大枚举质数primes[j]时，有两种情况：
> 1. i % primes[j] == 0，则primes[j]一定是i的最小质因子，且primes[j]一定是primes[j] * i的最小质因子
> 2. i % primes[j] != 0，则primes[j]一定小于i的所有质因子，但primes[j]一定是primes[j] * i的最小质因子
> （注意，这一条需要标注：当取`==`时就break了，因此`!=`的情况，讨论的都是`==`之前的；`==`之后的`!=`无意义）
> 
> 因此primes[j] * i总会被筛掉，也即是说质数的倍数总会被筛掉（i从2开始递增，保证不越界。当i枚举到x/pj时，任意合数x就被筛掉了）
> 一旦primes[j]是i的最小质因子，立刻break；否则继续找primes[j+1]，继续删的话，就会造成重复筛选
```c++
void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        // 添加质数。在下面的for循环中，质数的倍数都被筛掉了，所以这里可以安全地添加质数
        if (!st[i]) {
            primes[cnt++] = i;
        }
        // 从小到大枚举所有质数，循环条件等价于 primes[j] * i <= n，保证不越界
        // 循环中的break会保证不会越界访问已加入的质数，因此无需加循环条件 j < cnt
        for (int j = 0; primes[j] <= n / i; j++) {
            // 筛掉所有的合数（即所有质数的倍数）
            st[primes[j] * i] = true;

            // 确定枚举上限，保证不重复筛选
            if (i % primes[j] == 0) {
                break;
            }
        }
    }
}
```
