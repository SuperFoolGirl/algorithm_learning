// 高斯消元求解多元线性方程组（梦回线性代数）

// a11·x1 + a12·x2 + ... + a1n·xn = b1
// a21·x1 + a22·x2 + ... + a2n·xn = b2
// ...
// an1·x1 + an2·x2 + ... + ann·xn = bn
// 解的三种情况
// 1. 唯一解
// 2. 无解
// 3. 无穷多解

// 初等行列变换：
// 1. 每一行乘一个非0的数
// 2. 交换某两行
// 3. 把某行的若干倍加到另一行

// 判断解的情况（实际上是看矩阵的秩）
// 1. 完美阶梯型矩阵 —— 唯一解
// 2. 0 = 非零（系数矩阵与增广矩阵的秩不相等）—— 无解
// 3. 0 = 0（系数矩阵与增广矩阵的秩相等，但小于未知数的个数）—— 无穷多解

// 高斯消元详解：
// 1. 提取增广矩阵
// 2. 通过初等变换，变成上三角矩阵，即填充矩阵的右上角，满足阶梯型矩阵
//    初等变换方法：
//    1. 枚举每一列c的主元（注意，已经找完的行就不算主元了）
//       1. 找到这一列中绝对值最大的一行
//       2. 将该行换到最上方
//       3. 将该行第一个数换成1，行内其他数同除变换
//       4. 将下面（上面的主元不管）所有行的当前列消成0（通过初等变换3）
//       5. 重复上述工作，直到处理完系数的所有列

//    然后进行解的判断。在有解的情况下，进行第二部分推答案

//    2. 通过初等变换3，化为最简矩阵，直接出结果
//       1. 从最下面一行开始，消掉倒数第二行、第三行...直到消掉倒数第一行，执行n-1次
//       2. 重复上述工作，直到第二行消掉第一行，执行1次

#include <algorithm>
#include <cmath>
#include <cstring>
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;
const double eps = 1e-6;    // 用于浮点数正负判断

int n;
double a[N][N];

// 返回0：唯一解
// 返回1：无穷多解
// 返回2：无解
int gauss() {
    int c, r;    // 记录全局当前行列
    // 枚举列
    for (c = 0; c < n; c++) {
        // 1. 找绝对值最大的一行
        int t = r;    // 备选答案
        for (int i = r; i < n; i++) {
            if (fabs(a[i][c]) > fabs(a[t][c])) {
                t = i;
            }
        }

        // 如果本行主元为0
        if (fabs(a[t][c]) < eps) {
            continue;
        }

        // 2. 将改行换到最上方
        for (int i = c; i < n; i++) {
            swap(a[r][i], a[t][i]);
        }

        // 3. 系数化1，需要倒序更新
        for (int i = n; i >= c; i--) {
            a[r][i] /= a[r][c];
        }

        // 4. 下面所有行的当前列消成0（整行的若干倍加过去）
        for (int i = r + 1; i < n; i++) {
            // 如果不是0，再操作
            if (fabs(a[i][c]) > eps) {
                for (int j = n; j >= c; j--) {
                    a[i][j] -= a[r][j] * a[i][c];    // 提示：c是固定列，r是固定行
                }
            }
        }

        // 5. 重复操作
        r++;
    }

    // 执行过continue后，r可能小于n，系数矩阵不满秩
    if (r < n) {
        // 进一步判断系数矩阵和增广矩阵的秩是否相等
        // 相等则为无穷多解，否则无解
        // 如果出现0 = 非零（系数矩阵与增广矩阵的秩不相等）—— 无解
        for (int i = r; i < n; i++) {    // 从r开始，系数矩阵都是0了，查增广矩阵最后一列
            if (fabs(a[i][n]) > eps) {
                return 2;                // 无解
            }
        }
        return 1;                        // 无穷多解
    }

    // 如果有解，则进行第二部分，倒推答案
    // 这里是从后往前，每个当前行i都要被自己下面的所有行消掉，j遍历的就是i下面的行
    // 消的时候，逻辑上只关注结果就行，即只处理最后一列a[i][n]
    for (int i = n - 1; i >= 0; i--) {
        for (int j = i + 1; j < n; j++) {
            a[i][n] -= a[i][j] * a[j][n];    // 这里不好理解的话画图，模拟一下初等行变换
        }
    }

    return 0;    // 唯一解
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n + 1; j++) {
            cin >> a[i][j];
        }
    }

    int t = gauss();

    if (t == 0) {
        for (int i = 0; i < n; i++) {
            printf("%.2lf\n", a[i][n]);
        }
    } else if (t == 1) {
        cout << "Infinite group solutions" << endl;
    } else {
        cout << "No solution" << endl;
    }

    return 0;
}
