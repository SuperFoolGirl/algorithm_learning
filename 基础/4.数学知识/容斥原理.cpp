// n个集合的并集，等于各集合元素个数之和，减去两两交集元素个数之和，再加上三三交集元素个数之和，依此类推，直到n个集合的交集
// 这个和的个数可以用组合数来求解，所有项数之和为2^n
// 由于涉及组合数之和，由高中知识可知，时间复杂度为O(2^n)
// 即 1 - 2 + 3 - 4 + ... + (-1)^(n-1) * n，加减交替

// 以 n = 3 为例：
// |S1 ∪ S2 ∪ S3| = |S1| + |S2| + |S3| - |S1 ∩ S2| - |S1 ∩ S3| - |S2 ∩ S3| + |S1 ∩ S2 ∩ S3|
// 这里绝对值符号表示集合中元素个数
// 项数为1 3 3 1，组合数为C(3,0), C(3,1), C(3,2), C(3,3)


// 890. 能被整除的数
// 给定整数n，以及m个不同的质数
// 求1~n中，能被m个质数中，至少一个整除的数的个数

// 给定一个例子：n为10，m为2，质数为2，3
// 设S2为2的倍数的集合，S3为3的倍数的集合
// S2 = {2, 4, 6, 8, 10}
// S3 = {3, 6, 9}
// 则|S2 ∩ S3| = S6 = {6}，这么做的前提是质数两两互质
// 互质的数，最大公因数为1，因此最小公倍数就是二者乘积。所以就可以用这种方式快速计算
// 则本题答案为 |S2 ∪ S3| = |S2| + |S3| - |S2 ∩ S3| = 5 + 3 - 1 = 7
// 实际计算中，求倍数的个数，直接 n / p 即可（下取整）

// 这里提一个技巧：2^n规模的算法，可以用到二进制来描述相关算法过程；二进制的形式还可以与“选或不选”模型进行相互转换
// 还是以|S1 ∪ S2 ∪ S3| = |S1| + |S2| + |S3| - |S1 ∩ S2| - |S1 ∩ S3| - |S2 ∩ S3| + |S1 ∩ S2 ∩ S3|为例
// |S1|对应二进制001，|S2|对应010，|S1 ∩ S3|对应101，|S1 ∩ S2 ∩ S3|对应111
// 除去000，共有2^n-1项

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5 + 10;

int main() {

}
