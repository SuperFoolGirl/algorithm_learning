### 组合计数

$$
C_a^b=\frac{a \times (a-1) \times \cdots \times (a-b+1)}{b!}\\
=\frac {a!} {b! \times (a-b)!}
$$

例如，$C_6^2=\frac {6 \times 5} {2 \times 1}$

##### 求解方法

1. 递推式
	
	> 时间复杂度$O(n^2)$
	>
	> 由于结果可用于查表，因此该方法适用于**询问次数多、数据范围小**的题目
	
   $$
	C_a^b=C_{a-1}^b+C_{a-1}^{b-1}
	$$
	使用递推式可以把所有值初始化出来，进而查表
    ```c++
	void init() {
		for (int i = 0; i < N; i++) {
			for (int j = 0; j <= i; j++) {
				if (!j) {
					c[i][j] = 1;
				} else {
					c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
				}
			}
		}
	}
    ```

​	

2. 预处理

	> 时间复杂度$O(n \log n)$
	>
	> 适用于**询问次数较多，数据范围较大**的题目

    根据 $C_a^b=\frac {a!} {b! \times (a-b)!}$ 

    预处理出来所有阶乘，然后直接计算出目标组合数即可。表达式如下：

   $$
    C_a^b=fact[a] \times infact[b-a] \times infact[b]
   $$

   ```c++
    // 用fact[i]来存储i的阶乘对mod取模的结果，这里mod取10^9+1
    // infact[i]存储i的阶乘对mod取模的逆元，即(i!)^(-1) mod (10^9+1)
    // 逆元就是与其本身乘积为1的元素
    // 由于 a / b (mod m) != a(mod m) / b(mod m)，因此这里使用逆元
   
    int qmi(int a, int k, int p) {
        int res = 1;
        while (k) {
            if (k & 1) {
                res = (LL)res * a % p;
            }
            a = (LL)a * a % p;
            k >>= 1;
        }
        return res;
    }
   
    int main() {
        fact[0] = infact[0] - 1;
        for (int i = 1; i < N; i++) {
            fact[i] = (LL)fact[i - 1] * i % mod;
            infact[i] = (LL)infact[i - 1] *qmi(i, mod - 2, mod) % mod;  // 求逆元，原理是费马定理
        }
    
        // 套公式打印目标组合数即可
        cin >> a >> b;
        cout << fact[a] * infact[b - a] % mod * infact[b] % mod << endl;  // 模mod防止溢出
    
        return 0;
    }
   ```



3. 卢卡斯定理

	> 时间复杂度$O(p \log N \log p)$
	>
	> 适用于**询问次数很少，数据范围非常大**的题目

​	定理如下：

$$
C_a^b=C_{a \pmod{p}}^{b \pmod{p}} \cdot C_{a/p}^{b/p} \pmod{p}
$$

   对于 $a,b<p$，直接用定义求 $C_a^b$ 即可

```c++
int qmi(int a, int k, int p) {
    int res = 1;
    while (k) {
        if (k & 1) {
            res = (LL)res * a % p;
        }
        a = (LL)a * a % p;
        k >>= 1;
    }
    return res;
}

int C(int a, int b) {
    int res = 1;
    for (int i = 1, j = a; i <= b; i++, j--) {
        // 根据定义，分子分母的乘项数目是相同的，都是b次
        // 分子从a开始乘b次，分母从b开始乘到1
        // 分母依然是乘逆元
        res = (LL)res * j % p;
        res = (LL)res * qmi(i, p - 2) % p;
    }
}

// lucas定理用于处理大范围数据，类型为long long
int lucas(LL a, LL b) {
    // 若a, b < p，直接用定义求
    if (a < p && b < p) {
        return C(a, b);
    }
    // 否则，使用lucas定理
    // 注意，定理中前项系数a%p和b%p必然满足小于p，因此直接使用C函数即可
    return (LL)C(a % p, b % p) * lucas(a / p, b / p) % p;
}

int main() {
    cin >> a >> b;
    cout << lucas(a, b) << endl;
    return 0;
}
```



4. 需要高精度来处理的超大数据

	思路很简单，分别实现高精度乘法和高精度除法，按照定义来计算即可，但效率偏低。

	这里给出解决方法，可以仅使用高精度乘法：

	**对 $a,b$ 分解质因数，以 $a$ 为例，得到 $p_1^{\alpha_1} \cdot p_2^{\alpha_2} \cdots p_k^{\alpha_k}$**

	**对于某个因子 $p$，$a!$ 中其个数为 $\lfloor \frac{a}{p} \rfloor + \lfloor \frac{a}{p^2} \rfloor + \cdots + \lfloor \frac{a}{p_k} \rfloor$**

	**即 $$1 \le i \le a$$ 中 $p,p^2, \cdots ,p^k$ 的倍数之和。这个计算方法是不重不漏的，详细可以听课数学知识3**

	**进而可以实现基于 $a$ 的质因数分解来实现用相同的因子来描述 $a!$ 的分解，注意并不是 $a!$ 的质因数分解**

```c++
int primes[N], cnt;
int sum[N];  // 求组合数整体每个质因子的次数
bool st[N];

// 高精度乘法
vector<int> mul(vector<int> &a, int b) {
    vector<int> c;
    int t = 0;
    
    for (int i = 0; i < a.size() || t; i++) {
        if (i < a.size()) {
            t += a[i] * b
        }
        c.push_back(t % 10);
        t /= 10;
    }
    return c;
}

// 线性筛素数
void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;
        }
        for (int j = 0; primes[j] <= n / i; j++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) {
                break;
            }
        }
    }
}

// 求n!中质因子p的个数（运用上述公式）
int get(int n, int p) {
    int res = 0;
    while (n) {
        res += n / p;
        n /= p;
    }
    return res;
}

int main() {
    int a, b;
    cin >> a >> b;
    
    // 预处理出1~a和1~b的质数。由于a>b，只算a即可
    get_primes(a);
    
    // 计算组合数，遍历所有可能的质因子
    for (int i = 0; i < cnt; i++) {
        // 取到当前质因子
        int p = primes[i];
        // 计算其在组合数中出现的总次数，也是将除法转为乘法的关键
        sum[i] = get(a, p) - get(b, p) - get(a - b, p);
    }
    
    // 高精度乘法计算
    vector<int> res;
    res.push_back(1);
    
    // 遍历所有质因子及其出现次数
    for (int i = 0; i < cnt; i++) {
        for (int j = 0; j < sum[i]; j++) {
            res = mul(res, primes[i]);
        }
    }
    
    // 倒序输出
    for (int i = res.size() - 1; i >= 0; i--) {
        printf("%d", res[i]);
    }
    puts("");
    
    return 0;
}
```

