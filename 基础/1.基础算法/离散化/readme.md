### 离散化
> 离散化是将连续的数值范围映射到一个有限的离散集合中，通常用于处理区间问题、坐标压缩等场景。
> 其背景一般是，连续的数值范围很大，但是数值个数却很少
> 由于范围过大，不能开一个那么大的数组，因此需要把这个范围映射到从0开始的一个数组中

涉及到映射，那么给人的感觉就很像哈希表了

可能遇到的问题：
1. 原数组中有重复元素，此时需要去重操作
   ```c++
   vector<int> a; // 储存待离散化的值
   sort(a.begin(), a.end()); // 先排序
   a.erase(unique(a.begin(), a.end()), a.end()); // 库函数去重，可以用双指针自己模拟实现
   ```
2. 如何算出`a[i]`离散化后的值：二分查找



### 一个具体的例子：区间修改和查询

假设有一个问题：

> 有一个非常长的数轴，范围是 [1,109]。
>
> 在这个数轴上，有 N 次操作，每次操作会给出一个区间 [L,R]，并要求在这个区间内加一个数。
>
> 最后，有 M 次查询，每次查询一个点 X 的值是多少。
>
> N,M≤105。

- 我们需要一个数据结构来表示这个数轴。
- 因为数轴范围是 109，所以不能用一个 `int arr[10^9]` 这样的数组来存储，因为内存不够。
- 这时候，问题就卡住了。



### 为什么需要离散化？

仔细观察这个问题，发现虽然数轴的范围很大，但我们关心的点其实只有**有限个**：

- 所有的区间左端点$ L$
- 所有的区间右端点$ R$
- 所有的查询点 $X$

假设 $N=2,M=2$，操作和查询如下：

1. 区间$ [100,200]$ 加 1。
2. 区间$ [300,400]$ 加 1。
3. 查询点 $150$ 的值。
4. 查询点 $350$ 的值。

我们真正关心的“特殊点”有哪些？

- 区间端点：100, 200, 300, 400
- 查询点：150, 350

所以，虽然数轴范围是 109，但所有涉及到的有意义的点的数量非常有限，最多只有 $2×N+M$个，也就是$ 2×105+105=3×105$ 个。



### 离散化的思想就是：

> **既然我们只关心这有限的几个特殊点，那么我们就不需要去管数轴上那几十亿个“无趣”的点，而只专注于这有限的 3×105 个特殊点。**

我们用这 3×105 个点，将整个数轴切成有限个小区间。**在这些小区间内部，任何一个点的操作结果都是一样的。**



### 离散化的具体步骤（以这个例子为例）

#### 1. 把所有“特殊点”收集起来

我们收集所有区间端点和查询点。

- 操作1: [100,200] -> 收集 `100`, `200`
- 操作2: [300,400] -> 收集 `300`, `400`
- 查询1: 点 150 -> 收集 `150`
- 查询2: 点 350 -> 收集 `350`
- **所有特殊点集合：`{100, 200, 300, 400, 150, 350}`**

为了处理区间加，需要将区间端点稍微处理一下，变成 `[L, R+1]` 的形式，方便用差分数组（或树状数组）来处理。所以收集 `100, 201, 300, 401, 150, 350`。

- **所有特殊点集合：`{100, 201, 300, 401, 150, 350}`**



#### 2. 去重、排序，然后建立映射关系

- **去重并排序：**
	- `alls = {100, 150, 201, 300, 350, 401}`
	- 这里需要说一点的是，我们是把所有的数据提取出来，放进alls数组中，准备进行离散化
	- 去重操作并不影响后续取到这些数据。取这些数据的时候，是根据二分查找来映射对应位次的。
- **建立映射关系：** 我们把这些点看作一个新的、紧凑的数轴。
	- `100` -> 第 0 个特殊点
	- `150` -> 第 1 个特殊点
	- `201` -> 第 2 个特殊点
	- `300` -> 第 3 个特殊点
	- `350` -> 第 4 个特殊点
	- `401` -> 第 5 个特殊点

现在，我们的数轴不再是 [1,109] 了，而是一个大小为 6 的、紧凑的数轴。



#### 3. 用二分查找进行映射和处理

- **为什么用二分查找？**
	- 离散化后的数组 `alls` 是**有序**的。
	- 我们要将一个原始值（比如 `150`）映射到它的新值（也就是它的排名）。
	- 在一个有序数组中查找某个元素的位置，最快的方式就是**二分查找**。
	- `std::lower_bound` 正好能帮我们找到一个元素在有序数组中的位置，它的索引就是我们想要的新值。
- **将所有操作和查询点都映射到新值：**
	- 操作1: 区间 [100,200] 加 1。
		- `100` 在 `alls` 中的位置是 `0`。
		- `200` 在 `alls` 中**没有**，但我们知道它在 `150` 和 `201` 之间。我们可以用差分数组的技巧，把这个操作看作在 `100` 处加 1，在 `201` 处减 1。
		- **所以操作1变成了：在新的数轴的 `0` 号位加 1，在 `2` 号位减 1。**
	- 查询1: 点 `150`。
		- `150` 在 `alls` 中的位置是 `1`。
		- **查询1变成了：查询新的数轴上 `1` 号位的值。**



#### 4. 解决问题

现在，我们把一个范围巨大的问题，转化成了一个范围很小（0 到 `alls.size() - 1`）的问题。我们可以用一个大小为 3×105 的差分数组来解决。

- `diff[0]` 加 1

- `diff[2]` 减 1

- `diff[3]` 加 1

- `diff[5]`减 1

	然后对 diff 数组求前缀和，得到每个区间的最终值。

- 查询 `150` 的值，就相当于查询前缀和数组 `prefix_sum[1]`。

- 查询 `350` 的值，就相当于查询前缀和数组 `prefix_sum[4]`。