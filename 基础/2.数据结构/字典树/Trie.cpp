// 高效地存储和查找字符串集合
// 以两个字符串abcd, abfg为例，Trie树的结构如下：
//               root
//               /
//             a
//            /
//           b
//         /  \
//        c    f
//       /      \
//      d        g
// 对于有公共前缀的字符串，Trie树可以节省存储空间
// 对于单词结尾的字符，要进行标记。以上树为例，如果再加一个字符串abc，c不加标记的话，无法判断abc是否属于存储的单词

// 题目：维护一个字符串集合，支持两种操作：
// 1. I x：插入字符串x
// 2. Q x：查询字符串x是否在集合中
// （保证字符串只含有小写字母，因此树的每个节点最多有26个子节点）
// 输入格式：
// 第一行包含一个整数n，表示操作的数量
// 接下来n行，每行包含一个操作，操作格式为I x或Q x，其中x是一个字符串

#include <algorithm>
#include <cstring>
#include <iostream>

using namespace std;

const int N = 2e4 + 10;
int n;
// 用二维数组来模拟树
// 对于son数组，下标1为当前要处理的节点编号（插入时的idx），下标2为要找的子结点索引。给定这两个参数，就能找到当前节点的目标子结点
// 所有的静态数据结构，数组里放的都是idx的值
// 在这个数据结构中，idx值本身意义不大，只是意味着创建节点的顺序
int son[N][26], cnt[N], idx;    // son[i][j]表示节点i的第j个子节点，cnt[i]表示以节点i结尾的字符串数量。idx为0为根节点、空节点

// 传入一个字符串，插入到Trie树中
void insert(char str[]) {
    int p = 0;    // 从根节点开始
    // 注意这个循环条件，字符串结尾为'\0'，因此要用str[i]来判断是否到达字符串末尾
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';     // 当前字符对应的子节点索引，把小写字母转换为0-25的索引
        if (!son[p][u]) {         // 如果当前节点没有这个子节点，则创建它
            son[p][u] = ++idx;    // 创建新节点，并更新索引
        }
        p = son[p][u];            // 移动到下一个节点，继续插入下一个字母
    }
    // 注意，只有是同一个字符串出现第2次，cnt[p]才会大于1。正常情况下要么0要么1
    // p的赋值为son数组的值，即一个唯一的idx
    // 因此，Trie树支持多次插入同一个字符串
    cnt[p]++;    // 到达字符串末尾，更新当前节点的计数
}

// 查询字符串在Trie树中出现多少次
int query(char str[]) {
    int p = 0;                   // 从根节点开始
    for (int i = 0; str[i]; i++) {
        int u = str[i] - 'a';    // 当前字符对应的子节点索引
        if (!son[p][u]) {        // 如果当前节点没有这个子节点，则说明字符串不在Trie树中
            return 0;            // 返回0，表示未找到
        }
        p = son[p][u];           // 移动到下一个节点
    }
    return cnt[p];               // 返回当前节点的计数，即字符串出现的次数
}

int main() {
    cin >> n;
    char op[2], str[100];
    while (n--) {
        cin >> op >> str;
        if (op[0] == 'I') {
            insert(str);
        } else {
            cout << query(str) << endl;
        }
    }
    return 0;
}
