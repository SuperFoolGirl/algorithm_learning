### KMP 算法核心思想

KMP 算法避免了朴素匹配算法中，当发生不匹配时，模式串（`pattern`）总是从头开始重新匹配的低效行为。它的核心是利用已经匹配过的前缀信息，通过一个**`next` 数组**（也称为失配函数）来高效地移动模式串，从而实现线性的时间复杂度。

* **`next` 数组**：`next[j]` 表示模式串 `P` 的子串 `P[0...j-1]` 中，最长的相等的**前缀**和**后缀**的长度。简单来说，`next[j]` 告诉我们，当 `P[j]` 和文本串 `T` 中的字符不匹配时，我们应该把 `j` 指针移动到哪里，以继续进行匹配。

使用一个具体的例子来演示：

* **文本串 (T)**：`ABACABABA`
* **模式串 (P)**：`ABABA`

---

### 第1步：计算 `next` 数组

在开始匹配之前，首先需要计算模式串 `P` 的 `next` 数组。

`P`: `A B A B A`
索引: `0 1 2 3 4`

* **`j=0`**: 模式串的第一个字符，没有前缀和后缀，`next[0] = -1` (这里采用一种常见的定义，方便后续计算)。
* **`j=1`**: 子串 `A`。前缀`A`，后缀`A`，最长相等前缀后缀长度为`0`。`next[1] = 0`。
* **`j=2`**: 子串 `AB`。前缀`A`，后缀`B`，没有相等的前缀和后缀。`next[2] = 0`。
* **`j=3`**: 子串 `ABA`。前缀有 `A`，`AB`。后缀有 `BA`，`A`。最长相等前缀后缀是 `A`，长度为 `1`。`next[3] = 1`。
* **`j=4`**: 子串 `ABAB`。前缀有 `A`，`AB`，`ABA`。后缀有 `BAB`，`AB`，`B`。最长相等前缀后缀是 `AB`，长度为 `2`。`next[4] = 2`。
* **`j=5`**: 子串 `ABABA`。前缀有 `A`，`AB`，`ABA`，`ABAB`。后缀有 `BABA`，`ABA`，`BA`，`A`。最长相等前缀后缀是 `ABA`，长度为 `3`。`next[5] = 3`。

因此，模式串 `P` 的 `next` 数组为：`[-1, 0, 0, 1, 2, 3]`。

---

### 第2步：模式匹配的可视化

用 `i` 指针遍历文本串 `T`，用 `j` 指针遍历模式串 `P`。

#### **匹配过程**

* **初始状态**：`i=0, j=0`
    `T`: **A** B A C A B A B A
    `P`: **A** B A B A
    `T[0]` 和 `P[0]` 匹配。`i` 和 `j` 都向后移动一位。
    
* **`i=1, j=1`**
    `T`: A **B** A C A B A B A
    `P`: A **B** A B A
    `T[1]` 和 `P[1]` 匹配。`i` 和 `j` 都向后移动一位。
    
* **`i=2, j=2`**
    `T`: A B **A** C A B A B A
    `P`: A B **A** B A
    `T[2]` 和 `P[2]` 匹配。`i` 和 `j` 都向后移动一位。
    
* **`i=3, j=3`**
    `T`: A B A **C** A B A B A
    `P`: A B A **B** A
    `T[3]` (`C`) 和 `P[3]` (`B`) **不匹配**！

#### **失配处理**

这是 KMP 算法的关键。发生不匹配时，我们不会将模式串 `P` 移动到 `i=1` 处重新开始匹配。

根据 `next[j]` 的定义，我们知道 `P` 的子串 `P[0...2]`（`ABA`）中，最长的前缀和后缀都是 `A`，长度为 `1`。
这意味着，在 `T` 中，我们已经匹配了 `T[0...2]` (`ABA`)，并且我们知道 `T[2]` (`A`) 和 `T[0]` (`A`) 是相等的。所以，我们可以直接将模式串的 `j` 指针移动到 `next[j]` 处，即 `next[3] = 1`。

* **不匹配后**：
    
    * `i` 指针不动，仍指向 `T[3]` (`C`)。
    * `j` 指针移动到 `next[3]`，即 `j=1`。
    
    `T`: A B A **C** A B A B A
    `P`:   A **B** A B A
    
* **`i=3, j=1`**
    `T[3]` (`C`) 和 `P[1]` (`B`) **不匹配**！

#### **继续失配处理**

再次发生不匹配。我们继续利用 `next` 数组。
* `i` 指针不动，仍指向 `T[3]` (`C`)。
* `j` 指针移动到 `next[j]`，即 `next[1] = 0`。

    `T`: A B A **C** A B A B A
    `P`: **A** B A B A
    
* **`i=3, j=0`**
    `T[3]` (`C`) 和 `P[0]` (`A`) **不匹配**！

#### **继续失配处理**

再次发生不匹配。
* `i` 指针不动，`j` 指针移动到 `next[j]`，即 `next[0] = -1`。
    当 `j` 等于 `-1` 时，表示模式串已经找不到任何可以匹配的前缀了，此时我们将 `i` 和 `j` 同时向前移动一步，`j` 变为 `0`。

* **`i=4, j=0`**
    `T`: A B A C **A** B A B A
    `P`: **A** B A B A
    `T[4]` (`A`) 和 `P[0]` (`A`) 匹配。`i` 和 `j` 都向后移动一位。

* **`i=5, j=1`**
    `T`: A B A C A **B** A B A
    `P`: A **B** A B A
    匹配。`i` 和 `j` 都向后移动一位。
    
* **`i=6, j=2`**
    `T`: A B A C A B **A** B A
    `P`: A B **A** B A
    匹配。`i` 和 `j` 都向后移动一位。
    
* **`i=7, j=3`**
    `T`: A B A C A B A **B** A
    `P`: A B A **B** A
    匹配。`i` 和 `j` 都向后移动一位。
    
* **`i=8, j=4`**
    `T`: A B A C A B A B **A**
    `P`: A B A B **A**
    匹配。`i` 和 `j` 都向后移动一位。
    

此时 `j=5`，等于模式串的长度。这意味着我们找到了一个完整的匹配，匹配起始位置是 `i - j = 8 - 5 = 3`。